#include<stdio.h>
#include <stdlib.h>
#include <time.h>
#include <Windows.h>
#include <conio.h>

#define VERTICAL 10
#define HORIZONTAL 10

/*
int stage[3][10] = 
{
	{0,1,0,0,1,1,1,0,0,0},
	{1,1,1,1,1,1,0,1,1,1},
	{0,1,1,1,0,1,1,1,0,0}
};
*/
int stage[3][10] =
{
	{0,1,0,0,0,0,0,0,0,0},
	{1,1,1,1,1,1,1,1,1,1},
	{0,1,0,0,0,0,0,0,0,0}
};

//스테이지 좌표
int stageX = 0;
int stageY = 1;

//맵의 기본 모양
int map[10][10] =
{
	{1,1,1,1,1,1,1,1,4,1},
	{7,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,0,0,0,5},
	{1,6,1,1,1,1,1,1,1,1},	
};
int i, j;

int playerX = 5;
int playerY = 5;

int key = 0;
int keyX;
int keyY;

int stopcounter;

void mapf();
void player_to_map();	//기본적인 맵표시

void start();					//시작시 행동
int randomf();					//랜덤난수 생성

int moving();					//움직임
void movecheck();			//움직임후처리

void mapupdate();			//맵 위치에 맞는 맵을 로딩

void mapup();					//맵 이동 함수
void mapdown();
void mapleft();
void mapright();

void keymake();				//열쇠제작

void test1();






void main(){test1();}






int randomf()
{
	srand(time(NULL));
	int random = 0;
	random = rand() % 8 + 1;
	//printf("%d\n",random);
	return random;
}

void mapf()		
{
	system("cls");
	for (i = 0; i < VERTICAL; i++)
	{
		for (j = 0; j < HORIZONTAL; j++)
		{
			if (map[i][j] == 0)
			{
				printf("□");
			}
			else if (map[i][j] == 1)
			{
				printf("■");
			}
			else if (map[i][j] == 2)
			{
				printf("※");
			}
			else if (map[i][j] == 3)
			{
				if (key == 0)
				{
					printf("☆");
				}
				else if(key ==1 )
				{
					printf("★");
				}
			}
			else if (map[i][j] == 4)
			{
				printf("↑");
			}
			else if (map[i][j] == 5)
			{
				printf("→");
			}
			else if (map[i][j] == 6)
			{
				printf("↓");
			}
			else if (map[i][j] == 7)
			{
				printf("←");
			}
		}
		printf("\n");
	}
}

void player_to_map()
{
	map[playerY][playerX] = 3;
}

void start()
{
	mapupdate();
	player_to_map();
	keymake();
}

//움직인 곳에 있는 옵젝값 리턴
int moving()
{
	char mchecker;
	mchecker = _getch();
	if (mchecker == -32)
	{
		mchecker = _getch();
		map[playerY][playerX] = 0;
		if (mchecker == 75)//왼쪽
		{
			if (playerX > 0)
			{
				if (map[playerY][playerX - 1] == 0)
				{
					playerX--;
					player_to_map();
					mapf();
					return 0;
				}
				else if (map[playerY][playerX - 1] == 1)
				{
					player_to_map();
					mapf();
					return 1;
				}
				else if (map[playerY][playerX - 1] == 2)
				{
					playerX--;
					player_to_map();
					return 2;
				}
				//좌향문
				else if (map[playerY][playerX - 1] == 7)
				{
					return 7;
				}
			}
		}
		else if (mchecker == 80)//아래
		{
			if (playerY < 9)
			{
				if (map[playerY+1][playerX] == 0)
				{
					playerY++;
					player_to_map();
					mapf();
					return 0;
				}
				else if (map[playerY+1][playerX] == 1)
				{
					player_to_map();
					mapf();
					return 1;
				}
				else if (map[playerY+1][playerX] == 2)
				{
					playerY++;
					player_to_map();
					return 2;
				}
				//하향문
				else if (map[playerY+1][playerX] == 6)
				{
					return 6;
				}
			}
		}
		else if (mchecker == 77)//오른쪽
		{
			if (playerX < 9)
			{
				if (map[playerY][playerX + 1] == 0)
				{
					playerX++;
					player_to_map();
					mapf();
					return 0;
				}
				else if (map[playerY][playerX + 1] == 1)
				{
					player_to_map();
					mapf();
					return 1;
				}
				else if (map[playerY][playerX + 1] == 2)
				{
					playerX++;
					player_to_map();
					return 2;
				}
				//우향문
				else if (map[playerY][playerX + 1] == 5)
				{
					return 5;
				}
			}
		}
		else if (mchecker == 72)//위
		{
			if (playerY > 0)
			{
				if (map[playerY - 1][playerX] == 0)
				{
					playerY--;
					player_to_map();
					mapf();
					return 0;
				}
				else if (map[playerY - 1][playerX] == 1)
				{
					player_to_map();
					mapf();
					return 1;
				}
				else if (map[playerY - 1][playerX] == 2)
				{
					playerY--;
					player_to_map();
					return 2;
				}
				//상향문
				else if (map[playerY - 1][playerX] == 4)
				{
					return 4;
				}
			}
		}
	}
	else if (mchecker == 27)
	{
	stopcounter++;
	}
	else
	{
		return 0;
	}
	return 0;
}

//함수 불러서 처리
void movecheck()
{
	switch (moving())
	{
	case 2:
		key = 1;
		mapf();
		break;
	case 4:
		if (key==1)
		mapup();
		break;
	case 5:
		if (key==1)
		mapright();
		break;
	case 6:
		if (key==1)
		mapdown();
		break;
	case 7:
		if(key==1)
		mapleft();
		break;
	}
}

void mapupdate()
{
	key = 0;
	for (i = 0; i < HORIZONTAL; i++)
	{
		map[i][0] = 1;
		map[i][9] = 1;
		map[0][i] = 1;
		map[9][i] = 1;
	}
	if ((stage[stageY-1][stageX] == 1) && (stageY > 0))//상향문
	{
		map[0][8] = 4;
	}
	if ((stage[stageY][stageX + 1] == 1) && (stageX < 9))//우향문
	{
		map[8][9] = 5;
	}
	if ((stage[stageY + 1][stageX] == 1) && (stageY < 2))//하향문
	{
		map[9][1] = 6;
	}
	if ((stage[stageY][stageX - 1] == 1) &&( stageX > 0))//좌향문
	{
		map[1][0] = 7;
	}
}

void mapup()
{
	map[playerY][playerX] = 0;
	stageY--;
	mapupdate();
	playerX = 1;
	playerY = 8;
	player_to_map();
	keymake();
	mapf();
}
void mapright()
{
	map[playerY][playerX] = 0;
	stageX++;
	mapupdate();
	playerX = 1;
	playerY = 1;
	player_to_map();
	keymake();
	mapf();
}
void mapdown()
{
	map[playerY][playerX] = 0;
	stageY++;
	mapupdate();
	playerX = 8;
	playerY = 1;
	player_to_map();
	keymake();
	mapf();
}
void mapleft()
{
	map[playerY][playerX] = 0;
	stageX--;
	mapupdate();
	playerX = 8;
	playerY = 8;
	player_to_map();
	keymake();
	mapf();
}

void keymake()
{
	while (1)
	{
		keyX = randomf();
		keyY = randomf();
		if (map[keyY][keyX] == 0)
		{
			map[keyY][keyX] = 2;
			break;
		}
	}
}


void test1()
{
	start();
redo:
	mapf();
	while (stopcounter % 2 == 0)
	{
		movecheck();
	}
	system("cls");
	printf("일시정지");
	char mch;
	while (1)
	{
		mch = _getch();
		if (mch == 27)
		{
			stopcounter--;
			goto redo;
		}
	}
}
